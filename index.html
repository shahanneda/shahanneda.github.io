<!DOCTYPE html>
<html>
<head>
  <style>
  .show{
  	overflow-y: hidden
  	height: 100px;

  }
	.text_code{
		color:white;
  	}
  	body{
  		background-color: black;
  	}
  	.shahanneda{
  		color:red;
  		font-size: 200px;
  		text-align: center;
  	}
  	.shahanneda2{
  		color:blue;
  		font-size: 50px;
  		text-align: center;
  	}
  	.shahanneda3{
  		color:orange;
  		font-size: 30px;
  		text-align: left;
  	}
  	.shahanneda4{
  		color:pink;
  		font-size: 25px;
  		text-align: left;
  	}
  </style>
</head>
<body>
 <div>
<!-- <strong><h1 class="centered">HEY</h1></strong> -->
<em><p class="shahanneda">Shahan Neda Realm</p></em>
<em><p class="shahanneda2">Loading, Please Wait</p></em>

<em><p class="shahanneda3">Can you find whats wrong with this room?</p></em>
<em><p class="shahanneda4">Click on the wrong thing</p></em>

<embed src="http://www.reece-eu.net/room/room.swf" quality="high" width="1024" height="768" type="application/x-shockwave-flash" pluginbase="http://www.macromedia.com/shockwave/download/index.cgi?P1_Prod_Version=ShockwaveFlash">

<div class="Show"></div>
<marquee behavior="scroll" direction="down" scrollamount="20" style="height:1000px;"><p class="text_code">
'use strict';<br>

<br>const inspect = require('util').inspect;<br>

<br>function assertPath(path) {<br>
  if (typeof path !== 'string') {<br>
    throw new TypeError('Path must be a string. Received ' + inspect(path));<br>
  }<br>
}<br>

<br>// Resolves . and .. elements in a path with directory names<br>
function normalizeStringWin32(path, allowAboveRoot) {<br>
  var res = '';<br>
  var lastSlash = -1;<br>
  var dots = 0;<br>
  var code;<br>
  for (var i = 0; i <= path.length; ++i) {<br>
    if (i < path.length)<br>
      code = path.charCodeAt(i);<br>
    else if (code === 47/*/*/ || code === 92/*\*/)<br>
      break;<br>
    else<br>
      code = 47/*/*/;<br>
    if (code === 47/*/*/ || code === 92/*\*/) {<br>
      if (lastSlash === i - 1 || dots === 1) {<br>
        // NOOP<br>
      } else if (lastSlash !== i - 1 && dots === 2) {<br>
        if (res.length < 2 ||<br>
            res.charCodeAt(res.length - 1) !== 46/*.*/ ||<br>
            res.charCodeAt(res.length - 2) !== 46/*.*/) {<br>
          if (res.length > 2) {<br>
            const start = res.length - 1;<br>
            var j = start;<br>
            for (; j >= 0; --j) {<br>
              if (res.charCodeAt(j) === 92/*\*/)<br>
                break;<br>
            }<br>
            if (j !== start) {<br>
              if (j === -1)<br>
                res = '';<br>
              else<br>
                res = res.slice(0, j);<br>
              lastSlash = i;<br>
              dots = 0;<br>
              continue;<br>
            }<br>
          } else if (res.length === 2 || res.length === 1) {<br>
            res = '';<br>
            lastSlash = i;<br>
            dots = 0;<br>
            continue;<br>
          }<br>
        }<br>
        if (allowAboveRoot) {<br>
          if (res.length > 0)<br>
            res += '\\..';<br>
          else<br>
            res = '..';<br>
        }<br>
      } else {<br>
        if (res.length > 0)<br>
          res += '\\' + path.slice(lastSlash + 1, i);<br>
        else<br>
          res = path.slice(lastSlash + 1, i);<br>
      }<br>
      lastSlash = i;<br>
      dots = 0;<br>
    } else if (code === 46/*.*/ && dots !== -1) {<br>
      ++dots;<br>
    } else {<br>
      dots = -1;<br>
    }<br>
  }<br>
  return res;<br>
}<br>

<br>// Resolves . and .. elements in a path with directory names<br>
function normalizeStringPosix(path, allowAboveRoot) {<br>
  var res = '';<br>
  var lastSlash = -1;<br>
  var dots = 0;<br>
  var code;<br>
  for (var i = 0; i <= path.length; ++i) {<br>
    if (i < path.length)<br>
      code = path.charCodeAt(i);<br>
    else if (code === 47/*/*/)<br>
      break;<br>
    else<br>
      code = 47/*/*/;<br>
    if (code === 47/*/*/) {<br>
      if (lastSlash === i - 1 || dots === 1) {<br>
        // NOOP<br>
      } else if (lastSlash !== i - 1 && dots === 2) {<br>
        if (res.length < 2 ||<br>
            res.charCodeAt(res.length - 1) !== 46/*.*/ ||<br>
            res.charCodeAt(res.length - 2) !== 46/*.*/) {<br>
          if (res.length > 2) {<br>
            const start = res.length - 1;<br>
            var j = start;<br>
            for (; j >= 0; --j) {<br>
              if (res.charCodeAt(j) === 47/*/*/)<br>
                break;<br>
            }<br>
            if (j !== start) {<br>
              if (j === -1)<br>
                res = '';<br>
              else<br>
                res = res.slice(0, j);<br>
              lastSlash = i;<br>
              dots = 0;<br>
              continue;<br>
            }<br>
          } else if (res.length === 2 || res.length === 1) {<br>
            res = '';<br>
            lastSlash = i;<br>
            dots = 0;<br>
            continue;<br>
          }<br>
        }<br>
        if (allowAboveRoot) {<br>
          if (res.length > 0)<br>
            res += '/..';<br>
          else<br>
            res = '..';<br>
        }<br>
      } else {<br>
        if (res.length > 0)<br>
          res += '/' + path.slice(lastSlash + 1, i);<br>
        else<br>
          res = path.slice(lastSlash + 1, i);<br>
      }<br>
      lastSlash = i;<br>
      dots = 0;<br>
    } else if (code === 46/*.*/ && dots !== -1) {<br>
      ++dots;<br>
    } else {<br>
      dots = -1;<br>
    }<br>
  }<br>
  return res;<br>
}<br>

<br>function _format(sep, pathObject) {<br>
  const dir = pathObject.dir || pathObject.root;<br>
  const base = pathObject.base ||<br>
    ((pathObject.name || '') + (pathObject.ext || ''));<br>
  if (!dir) {<br>
    return base;<br>
  }<br>
  if (dir === pathObject.root) {<br>
    return dir + base;<br>
  }<br>
  return dir + sep + base;<br>
}<br>

<br>const win32 = {<br>
  // path.resolve([from ...], to)<br>
  resolve: function resolve() {<br>
    var resolvedDevice = '';<br>
    var resolvedTail = '';<br>
    var resolvedAbsolute = false;<br>

<br>    for (var i = arguments.length - 1; i >= -1; i--) {<br>
      var path;<br>
      if (i >= 0) {<br>
        path = arguments[i];<br>
      } else if (!resolvedDevice) {<br>
        path = process.cwd();<br>
      } else {<br>
        // Windows has the concept of drive-specific current working<br>
        // directories. If we've resolved a drive letter but not yet an<br>
        // absolute path, get cwd for that drive. We're sure the device is not<br>
        // a UNC path at this points, because UNC paths are always absolute.<br>
        path = process.env['=' + resolvedDevice];<br>
        // Verify that a drive-local cwd was found and that it actually points<br>
        // to our drive. If not, default to the drive's root.<br>
        if (path === undefined ||<br>
            path.slice(0, 3).toLowerCase() !==<br>
              resolvedDevice.toLowerCase() + '\\') {<br>
          path = resolvedDevice + '\\';<br>
        }<br>
      }<br>

<br>      assertPath(path);<br>

<br>      // Skip empty entries<br>
      if (path.length === 0) {<br>
        continue;<br>
      }<br>

<br>      var len = path.length;<br>
      var rootEnd = 0;<br>
      var code = path.charCodeAt(0);<br>
      var device = '';<br>
      var isAbsolute = false;<br>

<br>      // Try to match a root<br>
      if (len > 1) {<br>
        if (code === 47/*/*/ || code === 92/*\*/) {<br>
          // Possible UNC root<br>

<br>          // If we started with a separator, we know we at least have an<br>
          // absolute path of some kind (UNC or otherwise)<br>
          isAbsolute = true;<br>

<br>          code = path.charCodeAt(1);<br>
          if (code === 47/*/*/ || code === 92/*\*/) {<br>
            // Matched double path separator at beginning<br>
            var j = 2;<br>
            var last = j;<br>
            // Match 1 or more non-path separators<br>
            for (; j < len; ++j) {<br>
              code = path.charCodeAt(j);<br>
              if (code === 47/*/*/ || code === 92/*\*/)<br>
                break;<br>
            }<br>
            if (j < len && j !== last) {<br>
              const firstPart = path.slice(last, j);<br>
              // Matched!<br>
              last = j;<br>
              // Match 1 or more path separators<br>
              for (; j < len; ++j) {<br>
                code = path.charCodeAt(j);<br>
                if (code !== 47/*/*/ && code !== 92/*\*/)<br>
                  break;<br>
              }<br>
              if (j < len && j !== last) {<br>
                // Matched!<br>
                last = j;<br>
                // Match 1 or more non-path separators<br>
                for (; j < len; ++j) {<br>
                  code = path.charCodeAt(j);<br>
                  if (code === 47/*/*/ || code === 92/*\*/)<br>
                    break;<br>
                }<br>
                if (j === len) {<br>
                  // We matched a UNC root only<br>

<br>                  device = '\\\\' + firstPart + '\\' + path.slice(last);<br>
                  rootEnd = j;<br>
                } else if (j !== last) {<br>
                  // We matched a UNC root with leftovers<br>

<br>                  device = '\\\\' + firstPart + '\\' + path.slice(last, j);<br>
                  rootEnd = j;<br>
                }<br>
              }<br>
            }<br>
          } else {<br>
            rootEnd = 1;<br>
          }<br>
        } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||<br>
                   (code >= 97/*a*/ && code <= 122/*z*/)) {<br>
          // Possible device root<br>

<br>          code = path.charCodeAt(1);<br>
          if (path.charCodeAt(1) === 58/*:*/) {<br>
            device = path.slice(0, 2);<br>
            rootEnd = 2;<br>
            if (len > 2) {<br>
              code = path.charCodeAt(2);<br>
              if (code === 47/*/*/ || code === 92/*\*/) {<br>
                // Treat separator following drive name as an absolute path<br>
                // indicator<br>
                isAbsolute = true;<br>
                rootEnd = 3;<br>
              }<br>
            }<br>
          }<br>
        }<br>
      } else if (code === 47/*/*/ || code === 92/*\*/) {<br>
        // `path` contains just a path separator<br>
        rootEnd = 1;<br>
        isAbsolute = true;<br>
      }<br>

<br>      if (device.length > 0 &&<br>
          resolvedDevice.length > 0 &&<br>
          device.toLowerCase() !== resolvedDevice.toLowerCase()) {<br>
        // This path points to another device so it is not applicable<br>
        continue;<br>
      }<br>

<br>      if (resolvedDevice.length === 0 && device.length > 0) {<br>
        resolvedDevice = device;<br>
      }<br>
      if (!resolvedAbsolute) {<br>
        resolvedTail = path.slice(rootEnd) + '\\' + resolvedTail;<br>
        resolvedAbsolute = isAbsolute;<br>
      }<br>

<br>      if (resolvedDevice.length > 0 && resolvedAbsolute) {<br>
        break;<br>
      }<br>
    }<br>

<br>    // At this point the path should be resolved to a full absolute path,<br>
    // but handle relative paths to be safe (might happen when process.cwd()<br>
    // fails)<br>

<br>    // Normalize the tail path<br>
    resolvedTail = normalizeStringWin32(resolvedTail, !resolvedAbsolute);<br>

<br>    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||<br>
           '.';<br>
  },<br>

<br>  normalize: function normalize(path) {<br>
    assertPath(path);<br>
    const len = path.length;<br>
    if (len === 0)<br>
      return '.';<br>
    var rootEnd = 0;<br>
    var code = path.charCodeAt(0);<br>
    var device;<br>
    var isAbsolute = false;<br>

<br>    // Try to match a root<br>
    if (len > 1) {<br>
      if (code === 47/*/*/ || code === 92/*\*/) {<br>
        // Possible UNC root<br>

<br>        // If we started with a separator, we know we at least have an absolute<br>
        // path of some kind (UNC or otherwise)<br>
        isAbsolute = true;<br>

<br>        code = path.charCodeAt(1);<br>
        if (code === 47/*/*/ || code === 92/*\*/) {<br>
          // Matched double path separator at beginning<br>
          var j = 2;<br>
          var last = j;<br>
          // Match 1 or more non-path separators<br>
          for (; j < len; ++j) {<br>
            code = path.charCodeAt(j);<br>
            if (code === 47/*/*/ || code === 92/*\*/)<br>
              break;<br>
          }<br>
          if (j < len && j !== last) {<br>
            const firstPart = path.slice(last, j);<br>
            // Matched!<br>
            last = j;<br>
            // Match 1 or more path separators<br>
            for (; j < len; ++j) {<br>
              code = path.charCodeAt(j);<br>
              if (code !== 47/*/*/ && code !== 92/*\*/)<br>
                break;<br>
            }<br>
            if (j < len && j !== last) {<br>
              // Matched!<br>
              last = j;<br>
              // Match 1 or more non-path separators<br>
              for (; j < len; ++j) {<br>
                code = path.charCodeAt(j);<br>
                if (code === 47/*/*/ || code === 92/*\*/)<br>
                  break;<br>
              }<br>
              if (j === len) {<br>
                // We matched a UNC root only<br>
                // Return the normalized version of the UNC root since there<br>
                // is nothing left to process<br>

<br>                return '\\\\' + firstPart + '\\' + path.slice(last) + '\\';<br>
              } else if (j !== last) {<br>
                // We matched a UNC root with leftovers<br>

<br>                device = '\\\\' + firstPart + '\\' + path.slice(last, j);<br>
                rootEnd = j;<br>
              }<br>
            }<br>
          }<br>
        } else {<br>
          rootEnd = 1;<br>
        }<br>
      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||<br>
                 (code >= 97/*a*/ && code <= 122/*z*/)) {<br>
        // Possible device root<br>

<br>        code = path.charCodeAt(1);<br>
        if (path.charCodeAt(1) === 58/*:*/) {<br>
          device = path.slice(0, 2);<br>
          rootEnd = 2;<br>
          if (len > 2) {<br>
            code = path.charCodeAt(2);<br>
            if (code === 47/*/*/ || code === 92/*\*/) {<br>
              // Treat separator following drive name as an absolute path<br>
              // indicator<br>
              isAbsolute = true;<br>
              rootEnd = 3;<br>
            }<br>
          }<br>
        }<br>
      }<br>
    } else if (code === 47/*/*/ || code === 92/*\*/) {<br>
      // `path` contains just a path separator, exit early to avoid unnecessary<br>
      // work<br>
      return '\\';<br>
    }<br>

<br>    code = path.charCodeAt(len - 1);<br>
    var trailingSeparator = (code === 47/*/*/ || code === 92/*\*/);<br>
    var tail;<br>
    if (rootEnd < len)<br>
      tail = normalizeStringWin32(path.slice(rootEnd), !isAbsolute);<br>
    else<br>
      tail = '';<br>
    if (tail.length === 0 && !isAbsolute)<br>
      tail = '.';<br>
    if (tail.length > 0 && trailingSeparator)<br>
      tail += '\\';<br>
    if (device === undefined) {<br>
      if (isAbsolute) {<br>
        if (tail.length > 0)<br>
          return '\\' + tail;<br>
        else<br>
          return '\\';<br>
      } else if (tail.length > 0) {<br>
        return tail;<br>
      } else {<br>
        return '';<br>
      }<br>
    } else {<br>
      if (isAbsolute) {<br>
        if (tail.length > 0)<br>
          return device + '\\' + tail;<br>
        else<br>
          return device + '\\';<br>
      } else if (tail.length > 0) {<br>
        return device + tail;<br>
      } else {<br>
        return device;<br>
      }<br>
    }<br>
  },<br>

<br>
<br>  isAbsolute: function isAbsolute(path) {<br>
    assertPath(path);<br>
    const len = path.length;<br>
    if (len === 0)<br>
      return false;<br>
    var code = path.charCodeAt(0);<br>
    if (code === 47/*/*/ || code === 92/*\*/) {<br>
      return true;<br>
    } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||<br>
               (code >= 97/*a*/ && code <= 122/*z*/)) {<br>
      // Possible device root<br>

<br>      if (len > 2 && path.charCodeAt(1) === 58/*:*/) {<br>
        code = path.charCodeAt(2);<br>
        if (code === 47/*/*/ || code === 92/*\*/)<br>
          return true;<br>
      }<br>
    }<br>
    return false;<br>
  },<br>

<br>
<br>  join: function join() {<br>
    if (arguments.length === 0)<br>
      return '.';<br>

<br>    var joined;<br>
    var firstPart;<br>
    for (var i = 0; i < arguments.length; ++i) {<br>
      var arg = arguments[i];<br>
      assertPath(arg);<br>
      if (arg.length > 0) {<br>
        if (joined === undefined)<br>
          joined = firstPart = arg;<br>
        else<br>
          joined += '\\' + arg;<br>
      }<br>
    }<br>

<br>    if (joined === undefined)<br>
      return '.';<br>

<br>    // Make sure that the joined path doesn't start with two slashes, because<br>
    // normalize() will mistake it for an UNC path then.<br>
    //<br>
    // This step is skipped when it is very clear that the user actually<br>
    // intended to point at an UNC path. This is assumed when the first<br>
    // non-empty string arguments starts with exactly two slashes followed by<br>
    // at least one more non-slash character.<br>
    //<br>
    // Note that for normalize() to treat a path as an UNC path it needs to<br>
    // have at least 2 components, so we don't filter for that here.<br>
    // This means that the user can use join to construct UNC paths from<br>
    // a server name and a share name; for example:<br>
    //   path.join('//server', 'share') -> '\\\\server\\share\\')<br>
    //var firstPart = paths[0];<br>
    var needsReplace = true;<br>
    var slashCount = 0;<br>
    var code = firstPart.charCodeAt(0);<br>
    if (code === 47/*/*/ || code === 92/*\*/) {<br>
      ++slashCount;<br>
      const firstLen = firstPart.length;<br>
      if (firstLen > 1) {<br>
        code = firstPart.charCodeAt(1);<br>
        if (code === 47/*/*/ || code === 92/*\*/) {<br>
          ++slashCount;<br>
          if (firstLen > 2) {<br>
            code = firstPart.charCodeAt(2);<br>
            if (code === 47/*/*/ || code === 92/*\*/)<br>
              ++slashCount;<br>
            else {<br>
              // We matched a UNC path in the first part<br>
              needsReplace = false;<br>
            }<br>
          }<br>
        }<br>
      }<br>
    }<br>
    if (needsReplace) {<br>
      // Find any more consecutive slashes we need to replace<br>
      for (; slashCount < joined.length; ++slashCount) {<br>
        code = joined.charCodeAt(slashCount);<br>
        if (code !== 47/*/*/ && code !== 92/*\*/)<br>
          break;<br>
      }<br>

<br>      // Replace the slashes if needed<br>
      if (slashCount >= 2)<br>
        joined = '\\' + joined.slice(slashCount);<br>
    }<br>

<br>    return win32.normalize(joined);<br>
  },<br>

<br>
<br>  // It will solve the relative path from `from` to `to`, for instance:<br>
  //  from = 'C:\\orandea\\test\\aaa'<br>
  //  to = 'C:\\orandea\\impl\\bbb'<br>
  // The output of the function should be: '..\\..\\impl\\bbb'<br>
  relative: function relative(from, to) {<br>
    assertPath(from);<br>
    assertPath(to);<br>

<br>    if (from === to)<br>
      return '';<br>

<br>    var fromOrig = win32.resolve(from);<br>
    var toOrig = win32.resolve(to);<br>

<br>    if (fromOrig === toOrig)<br>
      return '';<br>

<br>    from = fromOrig.toLowerCase();<br>
    to = toOrig.toLowerCase();<br>

<br>    if (from === to)<br>
      return '';<br>

<br>    // Trim any leading backslashes<br>
    var fromStart = 0;<br>
    for (; fromStart < from.length; ++fromStart) {<br>
      if (from.charCodeAt(fromStart) !== 92/*\*/)<br>
        break;<br>
    }<br>
    // Trim trailing backslashes (applicable to UNC paths only)<br>
    var fromEnd = from.length;<br>
    for (; fromEnd - 1 > fromStart; --fromEnd) {<br>
      if (from.charCodeAt(fromEnd - 1) !== 92/*\*/)<br>
        break;<br>
    }<br>
    var fromLen = (fromEnd - fromStart);<br>

<br>    // Trim any leading backslashes<br>
    var toStart = 0;<br>
    for (; toStart < to.length; ++toStart) {<br>
      if (to.charCodeAt(toStart) !== 92/*\*/)<br>
        break;<br>
    }<br>
    // Trim trailing backslashes (applicable to UNC paths only)<br>
    var toEnd = to.length;<br>
    for (; toEnd - 1 > toStart; --toEnd) {<br>
      if (to.charCodeAt(toEnd - 1) !== 92/*\*/)<br>
        break;<br>
    }<br>
    var toLen = (toEnd - toStart);<br>

<br>    // Compare paths to find the longest common path from root<br>
    var length = (fromLen < toLen ? fromLen : toLen);<br>
    var lastCommonSep = -1;<br>
    var i = 0;<br>
    for (; i <= length; ++i) {<br>
      if (i === length) {<br>
        if (toLen > length) {<br>
          if (to.charCodeAt(toStart + i) === 92/*\*/) {<br>
            // We get here if `from` is the exact base path for `to`.<br>
            // For example: from='C:\\foo\\bar'; to='C:\\foo\\bar\\baz'<br>
            return toOrig.slice(toStart + i + 1);<br>
          } else if (i === 2) {<br>
            // We get here if `from` is the device root.<br>
            // For example: from='C:\\'; to='C:\\foo'<br>
            return toOrig.slice(toStart + i);<br>
          }<br>
        }<br>
        if (fromLen > length) {<br>
          if (from.charCodeAt(fromStart + i) === 92/*\*/) {<br>
            // We get here if `to` is the exact base path for `from`.<br>
            // For example: from='C:\\foo\\bar'; to='C:\\foo'<br>
            lastCommonSep = i;<br>
          } else if (i === 2) {<br>
            // We get here if `to` is the device root.<br>
            // For example: from='C:\\foo\\bar'; to='C:\\'<br>
            lastCommonSep = 3;<br>
          }<br>
        }<br>
        break;<br>
      }<br>
      var fromCode = from.charCodeAt(fromStart + i);<br>
      var toCode = to.charCodeAt(toStart + i);<br>
      if (fromCode !== toCode)<br>
        break;<br>
      else if (fromCode === 92/*\*/)<br>
        lastCommonSep = i;<br>
    }<br>

<br>    // We found a mismatch before the first common path separator was seen, so<br>
    // return the original `to`.<br>
    // TODO: do this just for device roots (and not UNC paths)?<br>
    if (i !== length && lastCommonSep === -1) {<br>
      if (toStart > 0)<br>
        return toOrig.slice(toStart);<br>
      else<br>
        return toOrig;<br>
    }<br>

<br>    var out = '';<br>
    if (lastCommonSep === -1)<br>
      lastCommonSep = 0;<br>
    // Generate the relative path based on the path difference between `to` and<br>
    // `from`<br>
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {<br>
      if (i === fromEnd || from.charCodeAt(i) === 92/*\*/) {<br>
        if (out.length === 0)<br>
          out += '..';<br>
        else<br>
          out += '\\..';<br>
      }<br>
    }<br>

<br>    // Lastly, append the rest of the destination (`to`) path that comes after<br>
    // the common path parts<br>
    if (out.length > 0)<br>
      return out + toOrig.slice(toStart + lastCommonSep, toEnd);<br>
    else {<br>
      toStart += lastCommonSep;<br>
      if (toOrig.charCodeAt(toStart) === 92/*\*/)<br>
        ++toStart;<br>
      return toOrig.slice(toStart, toEnd);<br>
    }<br>
  },<br>

<br>
<br>  _makeLong: function _makeLong(path) {<br>
    // Note: this will *probably* throw somewhere.<br>
    if (typeof path !== 'string')<br>
      return path;<br>

<br>    if (path.length === 0) {<br>
      return '';<br>
    }<br>

<br>    const resolvedPath = win32.resolve(path);<br>

<br>    if (resolvedPath.length >= 3) {<br>
      var code = resolvedPath.charCodeAt(0);<br>
      if (code === 92/*\*/) {<br>
        // Possible UNC root<br>

<br>        if (resolvedPath.charCodeAt(1) === 92/*\*/) {<br>
          code = resolvedPath.charCodeAt(2);<br>
          if (code !== 63/*?*/ && code !== 46/*.*/) {<br>
            // Matched non-long UNC root, convert the path to a long UNC path<br>
            return '\\\\?\\UNC\\' + resolvedPath.slice(2);<br>
          }<br>
        }<br>
      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||<br>
                 (code >= 97/*a*/ && code <= 122/*z*/)) {<br>
        // Possible device root<br>

<br>        if (resolvedPath.charCodeAt(1) === 58/*:*/ &&<br>
            resolvedPath.charCodeAt(2) === 92/*\*/) {<br>
          // Matched device root, convert the path to a long UNC path<br>
          return '\\\\?\\' + resolvedPath;<br>
        }<br>
      }<br>
    }<br>

<br>    return path;<br>
  },<br>

<br>
<br>  dirname: function dirname(path) {<br>
    assertPath(path);<br>
    const len = path.length;<br>
    if (len === 0)<br>
      return '.';<br>
    var rootEnd = -1;<br>
    var end = -1;<br>
    var matchedSlash = true;<br>
    var offset = 0;<br>
    var code = path.charCodeAt(0);<br>

<br>    // Try to match a root<br>
    if (len > 1) {<br>
      if (code === 47/*/*/ || code === 92/*\*/) {<br>
        // Possible UNC root<br>

<br>        rootEnd = offset = 1;<br>

<br>        code = path.charCodeAt(1);<br>
        if (code === 47/*/*/ || code === 92/*\*/) {<br>
          // Matched double path separator at beginning<br>
          var j = 2;<br>
          var last = j;<br>
          // Match 1 or more non-path separators<br>
          for (; j < len; ++j) {<br>
            code = path.charCodeAt(j);<br>
            if (code === 47/*/*/ || code === 92/*\*/)<br>
              break;<br>
          }<br>
          if (j < len && j !== last) {<br>
            // Matched!<br>
            last = j;<br>
            // Match 1 or more path separators<br>
            for (; j < len; ++j) {<br>
              code = path.charCodeAt(j);<br>
              if (code !== 47/*/*/ && code !== 92/*\*/)<br>
                break;<br>
            }<br>
            if (j < len && j !== last) {<br>
              // Matched!<br>
              last = j;<br>
              // Match 1 or more non-path separators<br>
              for (; j < len; ++j) {<br>
                code = path.charCodeAt(j);<br>
                if (code === 47/*/*/ || code === 92/*\*/)<br>
                  break;<br>
              }<br>
              if (j === len) {<br>
                // We matched a UNC root only<br>
                return path;<br>
              }<br>
              if (j !== last) {<br>
                // We matched a UNC root with leftovers<br>

<br>                // Offset by 1 to include the separator after the UNC root to<br>
                // treat it as a "normal root" on top of a (UNC) root<br>
                rootEnd = offset = j + 1;<br>
              }<br>
            }<br>
          }<br>
        }<br>
      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||<br>
                 (code >= 97/*a*/ && code <= 122/*z*/)) {<br>
        // Possible device root<br>

<br>        code = path.charCodeAt(1);<br>
        if (path.charCodeAt(1) === 58/*:*/) {<br>
          rootEnd = offset = 2;<br>
          if (len > 2) {<br>
            code = path.charCodeAt(2);<br>
            if (code === 47/*/*/ || code === 92/*\*/)<br>
              rootEnd = offset = 3;<br>
          }<br>
        }<br>
      }<br>
    } else if (code === 47/*/*/ || code === 92/*\*/) {<br>
      return path[0];<br>
    }<br>

<br>    for (var i = len - 1; i >= offset; --i) {<br>
      code = path.charCodeAt(i);<br>
      if (code === 47/*/*/ || code === 92/*\*/) {<br>
        if (!matchedSlash) {<br>
          end = i;<br>
          break;<br>
        }<br>
      } else {<br>
        // We saw the first non-path separator<br>
        matchedSlash = false;<br>
      }<br>
    }<br>

<br>    if (end === -1) {<br>
      if (rootEnd === -1)<br>
        return '.';<br>
      else<br>
        end = rootEnd;<br>
    }<br>
    return path.slice(0, end);<br>
  },<br>

<br>
<br>  basename: function basename(path, ext) {<br>
    if (ext !== undefined && typeof ext !== 'string')<br>
      throw new TypeError('"ext" argument must be a string');<br>
    assertPath(path);<br>
    var start = 0;<br>
    var end = -1;<br>
    var matchedSlash = true;<br>
    var i;<br>

<br>    // Check for a drive letter prefix so as not to mistake the following<br>
    // path separator as an extra separator at the end of the path that can be<br>
    // disregarded<br>
    if (path.length >= 2) {<br>
      const drive = path.charCodeAt(0);<br>
      if ((drive >= 65/*A*/ && drive <= 90/*Z*/) ||<br>
          (drive >= 97/*a*/ && drive <= 122/*z*/)) {<br>
        if (path.charCodeAt(1) === 58/*:*/)<br>
          start = 2;<br>
      }<br>
    }<br>

<br>    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {<br>
      if (ext.length === path.length && ext === path)<br>
        return '';<br>
      var extIdx = ext.length - 1;<br>
      var firstNonSlashEnd = -1;<br>
      for (i = path.length - 1; i >= start; --i) {<br>
        const code = path.charCodeAt(i);<br>
        if (code === 47/*/*/ || code === 92/*\*/) {<br>
          // If we reached a path separator that was not part of a set of path<br>
          // separators at the end of the string, stop now<br>
          if (!matchedSlash) {<br>
            start = i + 1;<br>
            break;<br>
          }<br>
        } else {<br>
          if (firstNonSlashEnd === -1) {<br>
            // We saw the first non-path separator, remember this index in case<br>
            // we need it if the extension ends up not matching<br>
            matchedSlash = false;<br>
            firstNonSlashEnd = i + 1;<br>
          }<br>
          if (extIdx >= 0) {<br>
            // Try to match the explicit extension<br>
            if (code === ext.charCodeAt(extIdx)) {<br>
              if (--extIdx === -1) {<br>
                // We matched the extension, so mark this as the end of our path<br>
                // component<br>
                end = i;<br>
              }<br>
            } else {<br>
              // Extension does not match, so our result is the entire path<br>
              // component<br>
              extIdx = -1;<br>
              end = firstNonSlashEnd;<br>
            }<br>
          }<br>
        }<br>
      }<br>

<br>      if (start === end)<br>
        end = firstNonSlashEnd;<br>
      else if (end === -1)<br>
        end = path.length;<br>
      return path.slice(start, end);<br>
    } else {<br>
      for (i = path.length - 1; i >= start; --i) {<br>
        const code = path.charCodeAt(i);<br>
        if (code === 47/*/*/ || code === 92/*\*/) {<br>
          // If we reached a path separator that was not part of a set of path<br>
          // separators at the end of the string, stop now<br>
          if (!matchedSlash) {<br>
            start = i + 1;<br>
            break;<br>
          }<br>
        } else if (end === -1) {<br>
          // We saw the first non-path separator, mark this as the end of our<br>
          // path component<br>
          matchedSlash = false;<br>
          end = i + 1;<br>
        }<br>
      }<br>

<br>      if (end === -1)<br>
        return '';<br>
      return path.slice(start, end);<br>
    }<br>
  },<br>

<br>
<br>  extname: function extname(path) {<br>
    assertPath(path);<br>
    var startDot = -1;<br>
    var startPart = 0;<br>
    var end = -1;<br>
    var matchedSlash = true;<br>
    // Track the state of characters (if any) we see before our first dot and<br>
    // after any path separator we find<br>
    var preDotState = 0;<br>
    for (var i = path.length - 1; i >= 0; --i) {<br>
      const code = path.charCodeAt(i);<br>
      if (code === 47/*/*/ || code === 92/*\*/) {<br>
        // If we reached a path separator that was not part of a set of path<br>
        // separators at the end of the string, stop now<br>
        if (!matchedSlash) {<br>
          startPart = i + 1;<br>
          break;<br>
        }<br>
        continue;<br>
      }<br>
      if (end === -1) {<br>
        // We saw the first non-path separator, mark this as the end of our<br>
        // extension<br>
        matchedSlash = false;<br>
        end = i + 1;<br>
      }<br>
      if (code === 46/*.*/) {<br>
        // If this is our first dot, mark it as the start of our extension<br>
        if (startDot === -1)<br>
          startDot = i;<br>
        else if (preDotState !== 1)<br>
          preDotState = 1;<br>
      } else if (startDot !== -1) {<br>
        // We saw a non-dot and non-path separator before our dot, so we should<br>
        // have a good chance at having a non-empty extension<br>
        preDotState = -1;<br>
      }<br>
    }<br>

<br>    if (startDot === -1 ||<br>
        end === -1 ||<br>
        // We saw a non-dot character immediately before the dot<br>
        preDotState === 0 ||<br>
        // The (right-most) trimmed path component is exactly '..'<br>
        (preDotState === 1 &&<br>
         startDot === end - 1 &&<br>
         startDot === startPart + 1)) {<br>
      return '';<br>
    }<br>
    return path.slice(startDot, end);<br>
  },<br>

<br>
<br>  format: function format(pathObject) {<br>
    if (pathObject === null || typeof pathObject !== 'object') {<br>
      throw new TypeError(<br>
        `Parameter "pathObject" must be an object, not ${typeof pathObject}`<br>
      );<br>
    }<br>
    return _format('\\', pathObject);<br>
  },<br>

<br>
<br>  parse: function parse(path) {<br>
    assertPath(path);<br>

<br>    var ret = { root: '', dir: '', base: '', ext: '', name: '' };<br>
    if (path.length === 0)<br>
      return ret;<br>

<br>    var len = path.length;<br>
    var rootEnd = 0;<br>
    var code = path.charCodeAt(0);<br>
    var isAbsolute = false;<br>

<br>    // Try to match a root<br>
    if (len > 1) {<br>
      if (code === 47/*/*/ || code === 92/*\*/) {<br>
        // Possible UNC root<br>

<br>        isAbsolute = true;<br>

<br>        code = path.charCodeAt(1);<br>
        rootEnd = 1;<br>
        if (code === 47/*/*/ || code === 92/*\*/) {<br>
          // Matched double path separator at beginning<br>
          var j = 2;<br>
          var last = j;<br>
          // Match 1 or more non-path separators<br>
          for (; j < len; ++j) {<br>
            code = path.charCodeAt(j);<br>
            if (code === 47/*/*/ || code === 92/*\*/)<br>
              break;<br>
          }<br>
          if (j < len && j !== last) {<br>
            // Matched!<br>
            last = j;<br>
            // Match 1 or more path separators<br>
            for (; j < len; ++j) {<br>
              code = path.charCodeAt(j);<br>
              if (code !== 47/*/*/ && code !== 92/*\*/)<br>
                break;<br>
            }<br>
            if (j < len && j !== last) {<br>
              // Matched!<br>
              last = j;<br>
              // Match 1 or more non-path separators<br>
              for (; j < len; ++j) {<br>
                code = path.charCodeAt(j);<br>
                if (code === 47/*/*/ || code === 92/*\*/)<br>
                  break;<br>
              }<br>
              if (j === len) {<br>
                // We matched a UNC root only<br>

<br>                rootEnd = j;<br>
              } else if (j !== last) {<br>
                // We matched a UNC root with leftovers<br>

<br>                rootEnd = j + 1;<br>
              }<br>
            }<br>
          }<br>
        }<br>
      } else if ((code >= 65/*A*/ && code <= 90/*Z*/) ||<br>
                 (code >= 97/*a*/ && code <= 122/*z*/)) {<br>
        // Possible device root<br>

<br>        code = path.charCodeAt(1);<br>
        if (path.charCodeAt(1) === 58/*:*/) {<br>
          rootEnd = 2;<br>
          if (len > 2) {<br>
            code = path.charCodeAt(2);<br>
            if (code === 47/*/*/ || code === 92/*\*/) {<br>
              if (len === 3) {<br>
                // `path` contains just a drive root, exit early to avoid<br>
                // unnecessary work<br>
                ret.root = ret.dir = path.slice(0, 3);<br>
                return ret;<br>
              }<br>
              isAbsolute = true;<br>
              rootEnd = 3;<br>
            }<br>
          } else {<br>
            // `path` contains just a drive root, exit early to avoid<br>
            // unnecessary work<br>
            ret.root = ret.dir = path.slice(0, 2);<br>
            return ret;<br>
          }<br>
        }<br>
      }<br>
    } else if (code === 47/*/*/ || code === 92/*\*/) {<br>
      // `path` contains just a path separator, exit early to avoid<br>
      // unnecessary work<br>
      ret.root = ret.dir = path[0];<br>
      return ret;<br>
    }<br>

<br>    if (rootEnd > 0)<br>
      ret.root = path.slice(0, rootEnd);<br>

<br>    var startDot = -1;<br>
    var startPart = 0;<br>
    var end = -1;<br>
    var matchedSlash = true;<br>
    var i = path.length - 1;<br>

<br>    // Track the state of characters (if any) we see before our first dot and<br>
    // after any path separator we find<br>
    var preDotState = 0;<br>

<br>    // Get non-dir info<br>
    for (; i >= rootEnd; --i) {<br>
      code = path.charCodeAt(i);<br>
      if (code === 47/*/*/ || code === 92/*\*/) {<br>
        // If we reached a path separator that was not part of a set of path<br>
        // separators at the end of the string, stop now<br>
        if (!matchedSlash) {<br>
          startPart = i + 1;<br>
          break;<br>
        }<br>
        continue;<br>
      }<br>
      if (end === -1) {<br>
        // We saw the first non-path separator, mark this as the end of our<br>
        // extension<br>
        matchedSlash = false;<br>
        end = i + 1;<br>
      }<br>
      if (code === 46/*.*/) {<br>
        // If this is our first dot, mark it as the start of our extension<br>
        if (startDot === -1)<br>
          startDot = i;<br>
        else if (preDotState !== 1)<br>
          preDotState = 1;<br>
      } else if (startDot !== -1) {<br>
        // We saw a non-dot and non-path separator before our dot, so we should<br>
        // have a good chance at having a non-empty extension<br>
        preDotState = -1;<br>
      }<br>
    }<br>

<br>    if (startDot === -1 ||<br>
        end === -1 ||<br>
        // We saw a non-dot character immediately before the dot<br>
        preDotState === 0 ||<br>
        // The (right-most) trimmed path component is exactly '..'<br>
        (preDotState === 1 &&<br>
         startDot === end - 1 &&<br>
         startDot === startPart + 1)) {<br>
      if (end !== -1) {<br>
        if (startPart === 0 && isAbsolute)<br>
          ret.base = ret.name = path.slice(rootEnd, end);<br>
        else<br>
          ret.base = ret.name = path.slice(startPart, end);<br>
      }<br>
    } else {<br>
      if (startPart === 0 && isAbsolute) {<br>
        ret.name = path.slice(rootEnd, startDot);<br>
        ret.base = path.slice(rootEnd, end);<br>
      } else {<br>
        ret.name = path.slice(startPart, startDot);<br>
        ret.base = path.slice(startPart, end);<br>
      }<br>
      ret.ext = path.slice(startDot, end);<br>
    }<br>

<br>    if (startPart > 0)<br>
      ret.dir = path.slice(0, startPart - 1);<br>
    else if (isAbsolute)<br>
      ret.dir = path.slice(0, rootEnd);<br>

<br>    return ret;<br>
  },<br>

<br>
<br>  sep: '\\',<br>
  delimiter: ';',<br>
  win32: null,<br>
  posix: null<br>
};<br>

<br>
<br>const posix = {<br>
  // path.resolve([from ...], to)<br>
  resolve: function resolve() {<br>
    var resolvedPath = '';<br>
    var resolvedAbsolute = false;<br>
    var cwd;<br>

<br>    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {<br>
      var path;<br>
      if (i >= 0)<br>
        path = arguments[i];<br>
      else {<br>
        if (cwd === undefined)<br>
          cwd = process.cwd();<br>
        path = cwd;<br>
      }<br>

<br>      assertPath(path);<br>

<br>      // Skip empty entries<br>
      if (path.length === 0) {<br>
        continue;<br>
      }<br>

<br>      resolvedPath = path + '/' + resolvedPath;<br>
      resolvedAbsolute = path.charCodeAt(0) === 47/*/*/;<br>
    }<br>

<br>    // At this point the path should be resolved to a full absolute path, but<br>
    // handle relative paths to be safe (might happen when process.cwd() fails)<br>

<br>    // Normalize the path<br>
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);<br>

<br>    if (resolvedAbsolute) {<br>
      if (resolvedPath.length > 0)<br>
        return '/' + resolvedPath;<br>
      else<br>
        return '/';<br>
    } else if (resolvedPath.length > 0) {<br>
      return resolvedPath;<br>
    } else {<br>
      return '.';<br>
    }<br>
  },<br>

<br>
<br>  normalize: function normalize(path) {<br>
    assertPath(path);<br>

<br>    if (path.length === 0)<br>
      return '.';<br>

<br>    const isAbsolute = path.charCodeAt(0) === 47/*/*/;<br>
    const trailingSeparator = path.charCodeAt(path.length - 1) === 47/*/*/;<br>

<br>    // Normalize the path<br>
    path = normalizeStringPosix(path, !isAbsolute);<br>

<br>    if (path.length === 0 && !isAbsolute)<br>
      path = '.';<br>
    if (path.length > 0 && trailingSeparator)<br>
      path += '/';<br>

<br>    if (isAbsolute)<br>
      return '/' + path;<br>
    return path;<br>
  },<br>

<br>
<br>  isAbsolute: function isAbsolute(path) {<br>
    assertPath(path);<br>
    return path.length > 0 && path.charCodeAt(0) === 47/*/*/;<br>
  },<br>

<br>
<br>  join: function join() {<br>
    if (arguments.length === 0)<br>
      return '.';<br>
    var joined;<br>
    for (var i = 0; i < arguments.length; ++i) {<br>
      var arg = arguments[i];<br>
      assertPath(arg);<br>
      if (arg.length > 0) {<br>
        if (joined === undefined)<br>
          joined = arg;<br>
        else<br>
          joined += '/' + arg;<br>
      }<br>
    }<br>
    if (joined === undefined)<br>
      return '.';<br>
    return posix.normalize(joined);<br>
  },<br>

<br>
<br>  relative: function relative(from, to) {<br>
    assertPath(from);<br>
    assertPath(to);<br>

<br>    if (from === to)<br>
      return '';<br>

<br>    from = posix.resolve(from);<br>
    to = posix.resolve(to);<br>

<br>    if (from === to)<br>
      return '';<br>

<br>    // Trim any leading backslashes<br>
    var fromStart = 1;<br>
    for (; fromStart < from.length; ++fromStart) {<br>
      if (from.charCodeAt(fromStart) !== 47/*/*/)<br>
        break;<br>
    }<br>
    var fromEnd = from.length;<br>
    var fromLen = (fromEnd - fromStart);<br>

<br>    // Trim any leading backslashes<br>
    var toStart = 1;<br>
    for (; toStart < to.length; ++toStart) {<br>
      if (to.charCodeAt(toStart) !== 47/*/*/)<br>
        break;<br>
    }<br>
    var toEnd = to.length;<br>
    var toLen = (toEnd - toStart);<br>

<br>    // Compare paths to find the longest common path from root<br>
    var length = (fromLen < toLen ? fromLen : toLen);<br>
    var lastCommonSep = -1;<br>
    var i = 0;<br>
    for (; i <= length; ++i) {<br>
      if (i === length) {<br>
        if (toLen > length) {<br>
          if (to.charCodeAt(toStart + i) === 47/*/*/) {<br>
            // We get here if `from` is the exact base path for `to`.<br>
            // For example: from='/foo/bar'; to='/foo/bar/baz'<br>
            return to.slice(toStart + i + 1);<br>
          } else if (i === 0) {<br>
            // We get here if `from` is the root<br>
            // For example: from='/'; to='/foo'<br>
            return to.slice(toStart + i);<br>
          }<br>
        } else if (fromLen > length) {<br>
          if (from.charCodeAt(fromStart + i) === 47/*/*/) {<br>
            // We get here if `to` is the exact base path for `from`.<br>
            // For example: from='/foo/bar/baz'; to='/foo/bar'<br>
            lastCommonSep = i;<br>
          } else if (i === 0) {<br>
            // We get here if `to` is the root.<br>
            // For example: from='/foo'; to='/'<br>
            lastCommonSep = 0;<br>
          }<br>
        }<br>
        break;<br>
      }<br>
      var fromCode = from.charCodeAt(fromStart + i);<br>
      var toCode = to.charCodeAt(toStart + i);<br>
      if (fromCode !== toCode)<br>
        break;<br>
      else if (fromCode === 47/*/*/)<br>
        lastCommonSep = i;<br>
    }<br>

<br>    var out = '';<br>
    // Generate the relative path based on the path difference between `to`<br>
    // and `from`<br>
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {<br>
      if (i === fromEnd || from.charCodeAt(i) === 47/*/*/) {<br>
        if (out.length === 0)<br>
          out += '..';<br>
        else<br>
          out += '/..';<br>
      }<br>
    }<br>

<br>    // Lastly, append the rest of the destination (`to`) path that comes after<br>
    // the common path parts<br>
    if (out.length > 0)<br>
      return out + to.slice(toStart + lastCommonSep);<br>
    else {<br>
      toStart += lastCommonSep;<br>
      if (to.charCodeAt(toStart) === 47/*/*/)<br>
        ++toStart;<br>
      return to.slice(toStart);<br>
    }<br>
  },<br>

<br>
<br>  _makeLong: function _makeLong(path) {<br>
    return path;<br>
  },<br>

<br>
<br>  dirname: function dirname(path) {<br>
    assertPath(path);<br>
    if (path.length === 0)<br>
      return '.';<br>
    var code = path.charCodeAt(0);<br>
    var hasRoot = (code === 47/*/*/);<br>
    var end = -1;<br>
    var matchedSlash = true;<br>
    for (var i = path.length - 1; i >= 1; --i) {<br>
      code = path.charCodeAt(i);<br>
      if (code === 47/*/*/) {<br>
        if (!matchedSlash) {<br>
          end = i;<br>
          break;<br>
        }<br>
      } else {<br>
        // We saw the first non-path separator<br>
        matchedSlash = false;<br>
      }<br>
    }<br>

<br>    if (end === -1)<br>
      return hasRoot ? '/' : '.';<br>
    if (hasRoot && end === 1)<br>
      return '//';<br>
    return path.slice(0, end);<br>
  },<br>

<br>
<br>  basename: function basename(path, ext) {<br>
    if (ext !== undefined && typeof ext !== 'string')<br>
      throw new TypeError('"ext" argument must be a string');<br>
    assertPath(path);<br>

<br>    var start = 0;<br>
    var end = -1;<br>
    var matchedSlash = true;<br>
    var i;<br>

<br>    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {<br>
      if (ext.length === path.length && ext === path)<br>
        return '';<br>
      var extIdx = ext.length - 1;<br>
      var firstNonSlashEnd = -1;<br>
      for (i = path.length - 1; i >= 0; --i) {<br>
        const code = path.charCodeAt(i);<br>
        if (code === 47/*/*/) {<br>
          // If we reached a path separator that was not part of a set of path<br>
          // separators at the end of the string, stop now<br>
          if (!matchedSlash) {<br>
            start = i + 1;<br>
            break;<br>
          }<br>
        } else {<br>
          if (firstNonSlashEnd === -1) {<br>
            // We saw the first non-path separator, remember this index in case<br>
            // we need it if the extension ends up not matching<br>
            matchedSlash = false;<br>
            firstNonSlashEnd = i + 1;<br>
          }<br>
          if (extIdx >= 0) {<br>
            // Try to match the explicit extension<br>
            if (code === ext.charCodeAt(extIdx)) {<br>
              if (--extIdx === -1) {<br>
                // We matched the extension, so mark this as the end of our path<br>
                // component<br>
                end = i;<br>
              }<br>
            } else {<br>
              // Extension does not match, so our result is the entire path<br>
              // component<br>
              extIdx = -1;<br>
              end = firstNonSlashEnd;<br>
            }<br>
          }<br>
        }<br>
      }<br>

<br>      if (start === end)<br>
        end = firstNonSlashEnd;<br>
      else if (end === -1)<br>
        end = path.length;<br>
      return path.slice(start, end);<br>
    } else {<br>
      for (i = path.length - 1; i >= 0; --i) {<br>
        if (path.charCodeAt(i) === 47/*/*/) {<br>
          // If we reached a path separator that was not part of a set of path<br>
          // separators at the end of the string, stop now<br>
          if (!matchedSlash) {<br>
            start = i + 1;<br>
            break;<br>
          }<br>
        } else if (end === -1) {<br>
          // We saw the first non-path separator, mark this as the end of our<br>
          // path component<br>
          matchedSlash = false;<br>
          end = i + 1;<br>
        }<br>
      }<br>

<br>      if (end === -1)<br>
        return '';<br>
      return path.slice(start, end);<br>
    }<br>
  },<br>

<br>
<br>  extname: function extname(path) {<br>
    assertPath(path);<br>
    var startDot = -1;<br>
    var startPart = 0;<br>
    var end = -1;<br>
    var matchedSlash = true;<br>
    // Track the state of characters (if any) we see before our first dot and<br>
    // after any path separator we find<br>
    var preDotState = 0;<br>
    for (var i = path.length - 1; i >= 0; --i) {<br>
      const code = path.charCodeAt(i);<br>
      if (code === 47/*/*/) {<br>
        // If we reached a path separator that was not part of a set of path<br>
        // separators at the end of the string, stop now<br>
        if (!matchedSlash) {<br>
          startPart = i + 1;<br>
          break;<br>
        }<br>
        continue;<br>
      }<br>
      if (end === -1) {<br>
        // We saw the first non-path separator, mark this as the end of our<br>
        // extension<br>
        matchedSlash = false;<br>
        end = i + 1;<br>
      }<br>
      if (code === 46/*.*/) {<br>
        // If this is our first dot, mark it as the start of our extension<br>
        if (startDot === -1)<br>
          startDot = i;<br>
        else if (preDotState !== 1)<br>
          preDotState = 1;<br>
      } else if (startDot !== -1) {<br>
        // We saw a non-dot and non-path separator before our dot, so we should<br>
        // have a good chance at having a non-empty extension<br>
        preDotState = -1;<br>
      }<br>
    }<br>

<br>    if (startDot === -1 ||<br>
        end === -1 ||<br>
        // We saw a non-dot character immediately before the dot<br>
        preDotState === 0 ||<br>
        // The (right-most) trimmed path component is exactly '..'<br>
        (preDotState === 1 &&<br>
         startDot === end - 1 &&<br>
         startDot === startPart + 1)) {<br>
      return '';<br>
    }<br>
    return path.slice(startDot, end);<br>
  },<br>

<br>
<br>  format: function format(pathObject) {<br>
    if (pathObject === null || typeof pathObject !== 'object') {<br>
      throw new TypeError(<br>
        `Parameter "pathObject" must be an object, not ${typeof pathObject}`<br>
      );<br>
    }<br>
    return _format('/', pathObject);<br>
  },<br>

<br>
<br>  parse: function parse(path) {<br>
    assertPath(path);<br>

<br>    var ret = { root: '', dir: '', base: '', ext: '', name: '' };<br>
    if (path.length === 0)<br>
      return ret;<br>
    var code = path.charCodeAt(0);<br>
    var isAbsolute = (code === 47/*/*/);<br>
    var start;<br>
    if (isAbsolute) {<br>
      ret.root = '/';<br>
      start = 1;<br>
    } else {<br>
      start = 0;<br>
    }<br>
    var startDot = -1;<br>
    var startPart = 0;<br>
    var end = -1;<br>
    var matchedSlash = true;<br>
    var i = path.length - 1;<br>

<br>    // Track the state of characters (if any) we see before our first dot and<br>
    // after any path separator we find<br>
    var preDotState = 0;<br>

<br>    // Get non-dir info<br>
    for (; i >= start; --i) {<br>
      code = path.charCodeAt(i);<br>
      if (code === 47/*/*/) {<br>
        // If we reached a path separator that was not part of a set of path<br>
        // separators at the end of the string, stop now<br>
        if (!matchedSlash) {<br>
          startPart = i + 1;<br>
          break;<br>
        }<br>
        continue;<br>
      }<br>
      if (end === -1) {<br>
        // We saw the first non-path separator, mark this as the end of our<br>
        // extension<br>
        matchedSlash = false;<br>
        end = i + 1;<br>
      }<br>
      if (code === 46/*.*/) {<br>
        // If this is our first dot, mark it as the start of our extension<br>
        if (startDot === -1)<br>
          startDot = i;<br>
        else if (preDotState !== 1)<br>
          preDotState = 1;<br>
      } else if (startDot !== -1) {<br>
        // We saw a non-dot and non-path separator before our dot, so we should<br>
        // have a good chance at having a non-empty extension<br>
        preDotState = -1;<br>
      }<br>
    }<br>

<br>    if (startDot === -1 ||<br>
        end === -1 ||<br>
        // We saw a non-dot character immediately before the dot<br>
        preDotState === 0 ||<br>
        // The (right-most) trimmed path component is exactly '..'<br>
        (preDotState === 1 &&<br>
         startDot === end - 1 &&<br>
         startDot === startPart + 1)) {<br>
      if (end !== -1) {<br>
        if (startPart === 0 && isAbsolute)<br>
          ret.base = ret.name = path.slice(1, end);<br>
        else<br>
          ret.base = ret.name = path.slice(startPart, end);<br>
      }<br>
    } else {<br>
      if (startPart === 0 && isAbsolute) {<br>
        ret.name = path.slice(1, startDot);<br>
        ret.base = path.slice(1, end);<br>
      } else {<br>
        ret.name = path.slice(startPart, startDot);<br>
        ret.base = path.slice(startPart, end);<br>
      }<br>
      ret.ext = path.slice(startDot, end);<br>
    }<br>

<br>    if (startPart > 0)<br>
      ret.dir = path.slice(0, startPart - 1);<br>
    else if (isAbsolute)<br>
      ret.dir = '/';<br>

<br>    return ret;<br>
  },<br>

<br>
<br>  sep: '/',<br>
  delimiter: ':',<br>
  win32: null,<br>
  posix: null<br>
};<br>

<br>
<br>posix.win32 = win32.win32 = win32;<br>
posix.posix = win32.posix = posix;<br>

<br>
<br>if (process.platform === 'win32')<br>
  module.exports = win32;<br>
else<br>
  module.exports = posix;<br>

// Note: In 0.8 and before, crypto functions all defaulted to using<br>
// binary-encoded strings rather than buffers.<br>

<br>'use strict';<br>

<br>const internalUtil = require('internal/util');<br>
internalUtil.assertCrypto(exports);<br>

<br>exports.DEFAULT_ENCODING = 'buffer';<br>

<br>const constants = process.binding('constants').crypto;<br>
const binding = process.binding('crypto');<br>
const randomBytes = binding.randomBytes;<br>
const getCiphers = binding.getCiphers;<br>
const getHashes = binding.getHashes;<br>
const getCurves = binding.getCurves;<br>
const getFipsCrypto = binding.getFipsCrypto;<br>
const setFipsCrypto = binding.setFipsCrypto;<br>

<br>const Buffer = require('buffer').Buffer;<br>
const stream = require('stream');<br>
const util = require('util');<br>
const LazyTransform = require('internal/streams/lazy_transform');<br>

<br>const DH_GENERATOR = 2;<br>

<br>Object.defineProperty(exports, 'constants', {<br>
  configurable: false,<br>
  enumerable: true,<br>
  value: constants<br>
});<br>

<br>// This is here because many functions accepted binary strings without<br>
// any explicit encoding in older versions of node, and we don't want<br>
// to break them unnecessarily.<br>
function toBuf(str, encoding) {<br>
  if (typeof str === 'string') {<br>
    if (encoding === 'buffer' || !encoding)<br>
      encoding = 'utf8';<br>
    return Buffer.from(str, encoding);<br>
  }<br>
  return str;<br>
}<br>
exports._toBuf = toBuf;<br>

<br>
<br>const assert = require('assert');<br>
const StringDecoder = require('string_decoder').StringDecoder;<br>

<br>
<br>exports.createHash = exports.Hash = Hash;<br>
function Hash(algorithm, options) {<br>
  if (!(this instanceof Hash))<br>
    return new Hash(algorithm, options);<br>
  this._handle = new binding.Hash(algorithm);<br>
  LazyTransform.call(this, options);<br>
}<br>

<br>util.inherits(Hash, LazyTransform);<br>

<br>Hash.prototype._transform = function(chunk, encoding, callback) {<br>
  this._handle.update(chunk, encoding);<br>
  callback();<br>
};<br>

<br>Hash.prototype._flush = function(callback) {<br>
  this.push(this._handle.digest());<br>
  callback();<br>
};<br>

<br>Hash.prototype.update = function(data, encoding) {<br>
  encoding = encoding || exports.DEFAULT_ENCODING;<br>
  this._handle.update(data, encoding);<br>
  return this;<br>
};<br>

<br>
<br>Hash.prototype.digest = function(outputEncoding) {<br>
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;<br>
  return this._handle.digest(outputEncoding);<br>
};<br>

<br>
<br>exports.createHmac = exports.Hmac = Hmac;<br>

<br>function Hmac(hmac, key, options) {<br>
  if (!(this instanceof Hmac))<br>
    return new Hmac(hmac, key, options);<br>
  this._handle = new binding.Hmac();<br>
  this._handle.init(hmac, toBuf(key));<br>
  LazyTransform.call(this, options);<br>
}<br>

<br>util.inherits(Hmac, LazyTransform);<br>

<br>Hmac.prototype.update = Hash.prototype.update;<br>
Hmac.prototype.digest = Hash.prototype.digest;<br>
Hmac.prototype._flush = Hash.prototype._flush;<br>
Hmac.prototype._transform = Hash.prototype._transform;<br>

<br>
<br>function getDecoder(decoder, encoding) {<br>
  if (encoding === 'utf-8') encoding = 'utf8';  // Normalize encoding.<br>
  decoder = decoder || new StringDecoder(encoding);<br>
  assert(decoder.encoding === encoding, 'Cannot change encoding');<br>
  return decoder;<br>
}<br>

<br>
<br>exports.createCipher = exports.Cipher = Cipher;<br>
function Cipher(cipher, password, options) {<br>
  if (!(this instanceof Cipher))<br>
    return new Cipher(cipher, password, options);<br>
  this._handle = new binding.CipherBase(true);<br>

<br>  this._handle.init(cipher, toBuf(password));<br>
  this._decoder = null;<br>

<br>  LazyTransform.call(this, options);<br>
}<br>

<br>util.inherits(Cipher, LazyTransform);<br>

<br>Cipher.prototype._transform = function(chunk, encoding, callback) {<br>
  this.push(this._handle.update(chunk, encoding));<br>
  callback();<br>
};<br>

<br>Cipher.prototype._flush = function(callback) {<br>
  try {<br>
    this.push(this._handle.final());<br>
  } catch (e) {<br>
    callback(e);<br>
    return;<br>
  }<br>
  callback();<br>
};<br>

<br>Cipher.prototype.update = function(data, inputEncoding, outputEncoding) {<br>
  inputEncoding = inputEncoding || exports.DEFAULT_ENCODING;<br>
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;<br>

<br>  var ret = this._handle.update(data, inputEncoding);<br>

<br>  if (outputEncoding && outputEncoding !== 'buffer') {<br>
    this._decoder = getDecoder(this._decoder, outputEncoding);<br>
    ret = this._decoder.write(ret);<br>
  }<br>

<br>  return ret;<br>
};<br>

<br>
<br>Cipher.prototype.final = function(outputEncoding) {<br>
  outputEncoding = outputEncoding || exports.DEFAULT_ENCODING;<br>
  var ret = this._handle.final();<br>

<br>  if (outputEncoding && outputEncoding !== 'buffer') {<br>
    this._decoder = getDecoder(this._decoder, outputEncoding);<br>
    ret = this._decoder.end(ret);<br>
  }<br>

<br>  return ret;<br>
};<br>

<br>
<br>Cipher.prototype.setAutoPadding = function(ap) {<br>
  this._handle.setAutoPadding(ap);<br>
  return this;<br>
};<br>

<br>Cipher.prototype.getAuthTag = function() {<br>
  return this._handle.getAuthTag();<br>
};<br>

<br>
<br>Cipher.prototype.setAuthTag = function(tagbuf) {<br>
  this._handle.setAuthTag(tagbuf);<br>
};<br>

<br>Cipher.prototype.setAAD = function(aadbuf) {<br>
  this._handle.setAAD(aadbuf);<br>
};<br>

<br>exports.createCipheriv = exports.Cipheriv = Cipheriv;<br>
function Cipheriv(cipher, key, iv, options) {<br>
  if (!(this instanceof Cipheriv))<br>
    return new Cipheriv(cipher, key, iv, options);<br>
  this._handle = new binding.CipherBase(true);<br>
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));<br>
  this._decoder = null;<br>

<br>  LazyTransform.call(this, options);<br>
}<br>

<br>util.inherits(Cipheriv, LazyTransform);<br>

<br>Cipheriv.prototype._transform = Cipher.prototype._transform;<br>
Cipheriv.prototype._flush = Cipher.prototype._flush;<br>
Cipheriv.prototype.update = Cipher.prototype.update;<br>
Cipheriv.prototype.final = Cipher.prototype.final;<br>
Cipheriv.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;<br>
Cipheriv.prototype.getAuthTag = Cipher.prototype.getAuthTag;<br>
Cipheriv.prototype.setAuthTag = Cipher.prototype.setAuthTag;<br>
Cipheriv.prototype.setAAD = Cipher.prototype.setAAD;<br>

<br>exports.createDecipher = exports.Decipher = Decipher;<br>
function Decipher(cipher, password, options) {<br>
  if (!(this instanceof Decipher))<br>
    return new Decipher(cipher, password, options);<br>

<br>  this._handle = new binding.CipherBase(false);<br>
  this._handle.init(cipher, toBuf(password));<br>
  this._decoder = null;<br>

<br>  LazyTransform.call(this, options);<br>
}<br>

<br>util.inherits(Decipher, LazyTransform);<br>

<br>Decipher.prototype._transform = Cipher.prototype._transform;<br>
Decipher.prototype._flush = Cipher.prototype._flush;<br>
Decipher.prototype.update = Cipher.prototype.update;<br>
Decipher.prototype.final = Cipher.prototype.final;<br>
Decipher.prototype.finaltol = Cipher.prototype.final;<br>
Decipher.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;<br>
Decipher.prototype.getAuthTag = Cipher.prototype.getAuthTag;<br>
Decipher.prototype.setAuthTag = Cipher.prototype.setAuthTag;<br>
Decipher.prototype.setAAD = Cipher.prototype.setAAD;<br>

<br>
<br>exports.createDecipheriv = exports.Decipheriv = Decipheriv;<br>
function Decipheriv(cipher, key, iv, options) {<br>
  if (!(this instanceof Decipheriv))<br>
    return new Decipheriv(cipher, key, iv, options);<br>

<br>  this._handle = new binding.CipherBase(false);<br>
  this._handle.initiv(cipher, toBuf(key), toBuf(iv));<br>
  this._decoder = null;<br>

<br>  LazyTransform.call(this, options);<br>
}<br>

<br>util.inherits(Decipheriv, LazyTransform);<br>

<br>Decipheriv.prototype._transform = Cipher.prototype._transform;<br>
Decipheriv.prototype._flush = Cipher.prototype._flush;<br>
Decipheriv.prototype.update = Cipher.prototype.update;<br>
Decipheriv.prototype.final = Cipher.prototype.final;<br>
Decipheriv.prototype.finaltol = Cipher.prototype.final;<br>
Decipheriv.prototype.setAutoPadding = Cipher.prototype.setAutoPadding;<br>
Decipheriv.prototype.getAuthTag = Cipher.prototype.getAuthTag;<br>
Decipheriv.prototype.setAuthTag = Cipher.prototype.setAuthTag;<br>
Decipheriv.prototype.setAAD = Cipher.prototype.setAAD;<br>

<br>
<br>exports.createSign = exports.Sign = Sign;<br>
function Sign(algorithm, options) {<br>
  if (!(this instanceof Sign))<br>
    return new Sign(algorithm, options);<br>
  this._handle = new binding.Sign();<br>
  this._handle.init(algorithm);<br>

<br>  stream.Writable.call(this, options);<br>
}<br>

<br>util.inherits(Sign, stream.Writable);<br>

<br>Sign.prototype._write = function(chunk, encoding, callback) {<br>
  this._handle.update(chunk, encoding);<br>
  callback();<br>
};<br>

<br>Sign.prototype.update = Hash.prototype.update;<br>

<br>Sign.prototype.sign = function(options, encoding) {<br>
  if (!options)<br>
    throw new Error('No key provided to sign');<br>

<br>  var key = options.key || options;<br>
  var passphrase = options.passphrase || null;<br>
  var ret = this._handle.sign(toBuf(key), null, passphrase);<br>

<br>  encoding = encoding || exports.DEFAULT_ENCODING;<br>
  if (encoding && encoding !== 'buffer')<br>
    ret = ret.toString(encoding);<br>

<br>  return ret;<br>
};<br>

<br>
<br>exports.createVerify = exports.Verify = Verify;<br>
function Verify(algorithm, options) {<br>
  if (!(this instanceof Verify))<br>
    return new Verify(algorithm, options);<br>

<br>  this._handle = new binding.Verify();<br>
  this._handle.init(algorithm);<br>

<br>  stream.Writable.call(this, options);<br>
}<br>

<br>util.inherits(Verify, stream.Writable);<br>

<br>Verify.prototype._write = Sign.prototype._write;<br>
Verify.prototype.update = Sign.prototype.update;<br>

<br>Verify.prototype.verify = function(object, signature, sigEncoding) {<br>
  sigEncoding = sigEncoding || exports.DEFAULT_ENCODING;<br>
  return this._handle.verify(toBuf(object), toBuf(signature, sigEncoding));<br>
};<br>

<br>function rsaPublic(method, defaultPadding) {<br>
  return function(options, buffer) {<br>
    var key = options.key || options;<br>
    var padding = options.padding || defaultPadding;<br>
    var passphrase = options.passphrase || null;<br>
    return method(toBuf(key), buffer, padding, passphrase);<br>
  };<br>
}<br>

<br>function rsaPrivate(method, defaultPadding) {<br>
  return function(options, buffer) {<br>
    var key = options.key || options;<br>
    var passphrase = options.passphrase || null;<br>
    var padding = options.padding || defaultPadding;<br>
    return method(toBuf(key), buffer, padding, passphrase);<br>
  };<br>
}<br>

<br>exports.publicEncrypt = rsaPublic(binding.publicEncrypt,<br>
                                  constants.RSA_PKCS1_OAEP_PADDING);<br>
exports.publicDecrypt = rsaPublic(binding.publicDecrypt,<br>
                                  constants.RSA_PKCS1_PADDING);<br>
exports.privateEncrypt = rsaPrivate(binding.privateEncrypt,<br>
                                    constants.RSA_PKCS1_PADDING);<br>
exports.privateDecrypt = rsaPrivate(binding.privateDecrypt,<br>
                                    constants.RSA_PKCS1_OAEP_PADDING);<br>

<br>
<br>exports.createDiffieHellman = exports.DiffieHellman = DiffieHellman;<br>

<br>function DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding) {<br>
  if (!(this instanceof DiffieHellman))<br>
    return new DiffieHellman(sizeOrKey, keyEncoding, generator, genEncoding);<br>

<br>  if (!(sizeOrKey instanceof Buffer) &&<br>
      typeof sizeOrKey !== 'number' &&<br>
      typeof sizeOrKey !== 'string')<br>
    throw new TypeError('First argument should be number, string or Buffer');<br>

<br>  if (keyEncoding) {<br>
    if (typeof keyEncoding !== 'string' ||<br>
        (!Buffer.isEncoding(keyEncoding) && keyEncoding !== 'buffer')) {<br>
      genEncoding = generator;<br>
      generator = keyEncoding;<br>
      keyEncoding = false;<br>
    }<br>
  }<br>

<br>  keyEncoding = keyEncoding || exports.DEFAULT_ENCODING;<br>
  genEncoding = genEncoding || exports.DEFAULT_ENCODING;<br>

<br>  if (typeof sizeOrKey !== 'number')<br>
    sizeOrKey = toBuf(sizeOrKey, keyEncoding);<br>

<br>  if (!generator)<br>
    generator = DH_GENERATOR;<br>
  else if (typeof generator !== 'number')<br>
    generator = toBuf(generator, genEncoding);<br>

<br>  this._handle = new binding.DiffieHellman(sizeOrKey, generator);<br>
  Object.defineProperty(this, 'verifyError', {<br>
    enumerable: true,<br>
    value: this._handle.verifyError,<br>
    writable: false<br>
  });<br>
}<br>

<br>
<br>exports.DiffieHellmanGroup =<br>
    exports.createDiffieHellmanGroup =<br>
    exports.getDiffieHellman = DiffieHellmanGroup;<br>

<br>function DiffieHellmanGroup(name) {<br>
  if (!(this instanceof DiffieHellmanGroup))<br>
    return new DiffieHellmanGroup(name);<br>
  this._handle = new binding.DiffieHellmanGroup(name);<br>
  Object.defineProperty(this, 'verifyError', {<br>
    enumerable: true,<br>
    value: this._handle.verifyError,<br>
    writable: false<br>
  });<br>
}<br>

<br>
<br>DiffieHellmanGroup.prototype.generateKeys =<br>
    DiffieHellman.prototype.generateKeys =<br>
    dhGenerateKeys;<br>

<br>function dhGenerateKeys(encoding) {<br>
  var keys = this._handle.generateKeys();<br>
  encoding = encoding || exports.DEFAULT_ENCODING;<br>
  if (encoding && encoding !== 'buffer')<br>
    keys = keys.toString(encoding);<br>
  return keys;<br>
}<br>

<br>
<br>DiffieHellmanGroup.prototype.computeSecret =<br>
    DiffieHellman.prototype.computeSecret =<br>
    dhComputeSecret;<br>

<br>function dhComputeSecret(key, inEnc, outEnc) {<br>
  inEnc = inEnc || exports.DEFAULT_ENCODING;<br>
  outEnc = outEnc || exports.DEFAULT_ENCODING;<br>
  var ret = this._handle.computeSecret(toBuf(key, inEnc));<br>
  if (outEnc && outEnc !== 'buffer')<br>
    ret = ret.toString(outEnc);<br>
  return ret;<br>
}<br>

<br>
<br>DiffieHellmanGroup.prototype.getPrime =<br>
    DiffieHellman.prototype.getPrime =<br>
    dhGetPrime;<br>

<br>function dhGetPrime(encoding) {<br>
  var prime = this._handle.getPrime();<br>
  encoding = encoding || exports.DEFAULT_ENCODING;<br>
  if (encoding && encoding !== 'buffer')<br>
    prime = prime.toString(encoding);<br>
  return prime;<br>
}<br>

<br>
<br>DiffieHellmanGroup.prototype.getGenerator =<br>
    DiffieHellman.prototype.getGenerator =<br>
    dhGetGenerator;<br>

<br>function dhGetGenerator(encoding) {<br>
  var generator = this._handle.getGenerator();<br>
  encoding = encoding || exports.DEFAULT_ENCODING;<br>
  if (encoding && encoding !== 'buffer')<br>
    generator = generator.toString(encoding);<br>
  return generator;<br>
}<br>

<br>
<br>DiffieHellmanGroup.prototype.getPublicKey =<br>
    DiffieHellman.prototype.getPublicKey =<br>
    dhGetPublicKey;<br>

<br>function dhGetPublicKey(encoding) {<br>
  var key = this._handle.getPublicKey();<br>
  encoding = encoding || exports.DEFAULT_ENCODING;<br>
  if (encoding && encoding !== 'buffer')<br>
    key = key.toString(encoding);<br>
  return key;<br>
}<br>

<br>
<br>DiffieHellmanGroup.prototype.getPrivateKey =<br>
    DiffieHellman.prototype.getPrivateKey =<br>
    dhGetPrivateKey;<br>

<br>function dhGetPrivateKey(encoding) {<br>
  var key = this._handle.getPrivateKey();<br>
  encoding = encoding || exports.DEFAULT_ENCODING;<br>
  if (encoding && encoding !== 'buffer')<br>
    key = key.toString(encoding);<br>
  return key;<br>
}<br>

<br>
<br>DiffieHellman.prototype.setPublicKey = function(key, encoding) {<br>
  encoding = encoding || exports.DEFAULT_ENCODING;<br>
  this._handle.setPublicKey(toBuf(key, encoding));<br>
  return this;<br>
};<br>

<br>
<br>DiffieHellman.prototype.setPrivateKey = function(key, encoding) {<br>
  encoding = encoding || exports.DEFAULT_ENCODING;<br>
  this._handle.setPrivateKey(toBuf(key, encoding));<br>
  return this;<br>
};<br>

<br>
<br>function ECDH(curve) {<br>
  if (typeof curve !== 'string')<br>
    throw new TypeError('"curve" argument should be a string');<br>

<br>  this._handle = new binding.ECDH(curve);<br>
}<br>

<br>exports.createECDH = function createECDH(curve) {<br>
  return new ECDH(curve);<br>
};<br>

<br>ECDH.prototype.computeSecret = DiffieHellman.prototype.computeSecret;<br>
ECDH.prototype.setPrivateKey = DiffieHellman.prototype.setPrivateKey;<br>
ECDH.prototype.setPublicKey = DiffieHellman.prototype.setPublicKey;<br>
ECDH.prototype.getPrivateKey = DiffieHellman.prototype.getPrivateKey;<br>

<br>ECDH.prototype.generateKeys = function generateKeys(encoding, format) {<br>
  this._handle.generateKeys();<br>

<br>  return this.getPublicKey(encoding, format);<br>
};<br>

<br>ECDH.prototype.getPublicKey = function getPublicKey(encoding, format) {<br>
  var f;<br>
  if (format) {<br>
    if (typeof format === 'number')<br>
      f = format;<br>
    if (format === 'compressed')<br>
      f = constants.POINT_CONVERSION_COMPRESSED;<br>
    else if (format === 'hybrid')<br>
      f = constants.POINT_CONVERSION_HYBRID;<br>
    // Default<br>
    else if (format === 'uncompressed')<br>
      f = constants.POINT_CONVERSION_UNCOMPRESSED;<br>
    else<br>
      throw new TypeError('Bad format: ' + format);<br>
  } else {<br>
    f = constants.POINT_CONVERSION_UNCOMPRESSED;<br>
  }<br>
  var key = this._handle.getPublicKey(f);<br>
  encoding = encoding || exports.DEFAULT_ENCODING;<br>
  if (encoding && encoding !== 'buffer')<br>
    key = key.toString(encoding);<br>
  return key;<br>
};<br>

<br>
<br>const pbkdf2DeprecationWarning =<br>
    internalUtil.deprecate(() => {}, 'crypto.pbkdf2 without specifying' +<br>
      ' a digest is deprecated. Please specify a digest');<br>

<br>
<br>exports.pbkdf2 = function(password,<br>
                          salt,<br>
                          iterations,<br>
                          keylen,<br>
                          digest,<br>
                          callback) {<br>
  if (typeof digest === 'function') {<br>
    callback = digest;<br>
    digest = undefined;<br>
    pbkdf2DeprecationWarning();<br>
  }<br>

<br>  if (typeof callback !== 'function')<br>
    throw new Error('No callback provided to pbkdf2');<br>

<br>  return pbkdf2(password, salt, iterations, keylen, digest, callback);<br>
};<br>

<br>
<br>exports.pbkdf2Sync = function(password, salt, iterations, keylen, digest) {<br>
  if (typeof digest === 'undefined') {<br>
    digest = undefined;<br>
    pbkdf2DeprecationWarning();<br>
  }<br>
  return pbkdf2(password, salt, iterations, keylen, digest);<br>
};<br>

<br>
<br>function pbkdf2(password, salt, iterations, keylen, digest, callback) {<br>
  password = toBuf(password);<br>
  salt = toBuf(salt);<br>

<br>  if (exports.DEFAULT_ENCODING === 'buffer')<br>
    return binding.PBKDF2(password, salt, iterations, keylen, digest, callback);<br>

<br>  // at this point, we need to handle encodings.<br>
  var encoding = exports.DEFAULT_ENCODING;<br>
  if (callback) {<br>
    var next = function(er, ret) {<br>
      if (ret)<br>
        ret = ret.toString(encoding);<br>
      callback(er, ret);<br>
    };<br>
    binding.PBKDF2(password, salt, iterations, keylen, digest, next);<br>
  } else {<br>
    var ret = binding.PBKDF2(password, salt, iterations, keylen, digest);<br>
    return ret.toString(encoding);<br>
  }<br>
}<br>

<br>
<br>exports.Certificate = Certificate;<br>

<br>function Certificate() {<br>
  if (!(this instanceof Certificate))<br>
    return new Certificate();<br>
}<br>

<br>
<br>Certificate.prototype.verifySpkac = function(object) {<br>
  return binding.certVerifySpkac(object);<br>
};<br>

<br>
<br>Certificate.prototype.exportPublicKey = function(object, encoding) {<br>
  return binding.certExportPublicKey(toBuf(object, encoding));<br>
};<br>

<br>
<br>Certificate.prototype.exportChallenge = function(object, encoding) {<br>
  return binding.certExportChallenge(toBuf(object, encoding));<br>
};<br>

<br>
<br>exports.setEngine = function setEngine(id, flags) {<br>
  if (typeof id !== 'string')<br>
    throw new TypeError('"id" argument should be a string');<br>

<br>  if (flags && typeof flags !== 'number')<br>
    throw new TypeError('"flags" argument should be a number, if present');<br>
  flags = flags >>> 0;<br>

<br>  // Use provided engine for everything by default<br>
  if (flags === 0)<br>
    flags = constants.ENGINE_METHOD_ALL;<br>

<br>  return binding.setEngine(id, flags);<br>
};<br>

<br>exports.randomBytes = exports.pseudoRandomBytes = randomBytes;<br>

<br>exports.rng = exports.prng = randomBytes;<br>

<br>exports.getCiphers = internalUtil.cachedResult(() => {<br>
  return internalUtil.filterDuplicateStrings(getCiphers());<br>
});<br>

<br>exports.getHashes = internalUtil.cachedResult(() => {<br>
  return internalUtil.filterDuplicateStrings(getHashes());<br>
});<br>

<br>exports.getCurves = internalUtil.cachedResult(() => {<br>
  return internalUtil.filterDuplicateStrings(getCurves());<br>
});<br>

<br>Object.defineProperty(exports, 'fips', {<br>
  get: getFipsCrypto,<br>
  set: setFipsCrypto<br>
});<br>

<br>// Legacy API<br>
Object.defineProperty(exports, 'createCredentials', {<br>
  configurable: true,<br>
  enumerable: true,<br>
  get: internalUtil.deprecate(function() {<br>
    return require('tls').createSecureContext;<br>
  }, 'crypto.createCredentials is deprecated. ' +<br>
     'Use tls.createSecureContext instead.')<br>
});<br>

<br>Object.defineProperty(exports, 'Credentials', {<br>
  configurable: true,<br>
  enumerable: true,<br>
  get: internalUtil.deprecate(function() {<br>
    return require('tls').SecureContext;<br>
  }, 'crypto.Credentials is deprecated. ' +<br>
     'Use tls.SecureContext instead.')<br>
});<br></marquee>


</p>
</div>
</body>
</html>
v